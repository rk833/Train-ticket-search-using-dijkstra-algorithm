{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Train Ticket Search System","text":"<p>This project implements a train ticket search system that finds optimal routes between railway stations using Dijkstra\u2019s shortest path algorithm.</p> <p>The railway network is modelled as a weighted graph, where stations are vertices and track connections are edges. The system allows users to search for routes optimised by cost or time and displays detailed journey results.</p>"},{"location":"#core-features","title":"Core Features","text":"<ul> <li>Graph-based railway network representation  </li> <li>Dijkstra\u2019s shortest path algorithm  </li> <li>Modular system architecture  </li> <li>Interactive console interface  </li> <li>Optimisation by distance or cost  </li> <li>CSV-based data loading  </li> </ul>"},{"location":"main/","title":"Main Program","text":"<p>This module is the entry point of the system. It loads the railway network, initialises the route searcher, and launches the user interface.</p>"},{"location":"main/#main_train","title":"main_train","text":"<p>Train Ticket Search System (Task 1.3)</p> <p>Finds optimal train routes using Dijkstra's shortest path algorithm and provides a console-based and Tkinter user interface.</p>"},{"location":"main/#main_train.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Load the railway network, initialize route searcher, and start the UI.</p> Source code in <code>main_train.py</code> <pre><code>def main():\n    \"\"\"Load the railway network, initialize route searcher, and start the UI.\"\"\"\n    print(\"Loading railway network...\")\n\n    # Create network object FIRST\n    network = RailwayNetwork()\n\n    # Build correct CSV path\n    base_dir = os.path.dirname(__file__)\n    csv_path = os.path.join(base_dir, \"railway_network.csv\")\n\n    # Load CSV\n    network.load_from_csv(csv_path)\n\n    # Create route searcher\n    searcher = RouteSearcher(network)\n\n    # Run user interface\n    ui = UserInterface(network, searcher)\n    ui.run()\n</code></pre>"},{"location":"railway_network/","title":"Railway Network","text":"<p>This module constructs and manages the railway graph. It loads station and connection data from a CSV file and stores it in an adjacency list representation.</p>"},{"location":"railway_network/#src.railway_network","title":"railway_network","text":""},{"location":"railway_network/#src.railway_network.RailwayNetwork","title":"RailwayNetwork","text":"<p>Represents a railway network as a graph with stations and connections.</p> Source code in <code>src\\railway_network.py</code> <pre><code>class RailwayNetwork:\n    \"\"\"\n    Represents a railway network as a graph with stations and connections.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initialize an empty railway network.\n        \"\"\"\n\n        # Graph structure: {station: [(neighbor, cost, time), ...]}\n        self.graph = {}\n\n        # Stores all station names\n        self.stations = set()\n\n    def load_from_csv(self, filename):\n        \"\"\"\n        Load railway stations and connections from a CSV file.\n\n        Each row in CSV should be: station1, station2, cost, time\n        \"\"\"\n        try:\n            with open(filename, 'r') as file:\n                csv_reader = csv.reader(file)\n\n                for row in csv_reader:\n\n                    # Skip invalid or broken rows\n                    if len(row) != 4:\n                        continue\n\n                    # Skip if row looks like header\n                    if row[0].lower() == 'station1' or not row[2].isdigit():\n                        continue\n\n                    # Parse each line\n                    station1 = row[0].strip()\n                    station2 = row[1].strip()\n                    cost = int(row[2].strip())\n                    time = int(row[3].strip())\n\n                    # Store station names\n                    self.stations.add(station1)\n                    self.stations.add(station2)\n\n                    # Create empty list if station not seen before\n                    if station1 not in self.graph:\n                        self.graph[station1] = []\n                    if station2 not in self.graph:\n                        self.graph[station2] = []\n\n                    # Add bidirectional edges\n                    # Each edge stores: (neighbor_station, cost, time)\n                    self.graph[station1].append((station2, cost, time))\n                    self.graph[station2].append((station1, cost, time))\n\n            print(f\" Network loaded: {len(self.stations)} stations, \"\n                  f\"{sum(len(neighbors) for neighbors in self.graph.values()) // 2} connections\")\n\n        except FileNotFoundError:\n            print(f\"Error: File '{filename}' not found!\")\n            exit(1)\n        except Exception as e:\n            print(f\"Error loading network: {e}\")\n            exit(1)\n\n    def get_neighbors(self, station):\n        \"\"\"\n        Return a list of neighboring stations with cost and time.\n        \"\"\"\n        return self.graph.get(station, [])\n\n    def station_exists(self, station):\n        \"\"\"\n        Check if a station exists in the network.\n        \"\"\"\n        return station in self.stations\n</code></pre>"},{"location":"railway_network/#src.railway_network.RailwayNetwork.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> <p>Initialize an empty railway network.</p> Source code in <code>src\\railway_network.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize an empty railway network.\n    \"\"\"\n\n    # Graph structure: {station: [(neighbor, cost, time), ...]}\n    self.graph = {}\n\n    # Stores all station names\n    self.stations = set()\n</code></pre>"},{"location":"railway_network/#src.railway_network.RailwayNetwork.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(station)\n</code></pre> <p>Return a list of neighboring stations with cost and time.</p> Source code in <code>src\\railway_network.py</code> <pre><code>def get_neighbors(self, station):\n    \"\"\"\n    Return a list of neighboring stations with cost and time.\n    \"\"\"\n    return self.graph.get(station, [])\n</code></pre>"},{"location":"railway_network/#src.railway_network.RailwayNetwork.load_from_csv","title":"load_from_csv","text":"<pre><code>load_from_csv(filename)\n</code></pre> <p>Load railway stations and connections from a CSV file.</p> <p>Each row in CSV should be: station1, station2, cost, time</p> Source code in <code>src\\railway_network.py</code> <pre><code>def load_from_csv(self, filename):\n    \"\"\"\n    Load railway stations and connections from a CSV file.\n\n    Each row in CSV should be: station1, station2, cost, time\n    \"\"\"\n    try:\n        with open(filename, 'r') as file:\n            csv_reader = csv.reader(file)\n\n            for row in csv_reader:\n\n                # Skip invalid or broken rows\n                if len(row) != 4:\n                    continue\n\n                # Skip if row looks like header\n                if row[0].lower() == 'station1' or not row[2].isdigit():\n                    continue\n\n                # Parse each line\n                station1 = row[0].strip()\n                station2 = row[1].strip()\n                cost = int(row[2].strip())\n                time = int(row[3].strip())\n\n                # Store station names\n                self.stations.add(station1)\n                self.stations.add(station2)\n\n                # Create empty list if station not seen before\n                if station1 not in self.graph:\n                    self.graph[station1] = []\n                if station2 not in self.graph:\n                    self.graph[station2] = []\n\n                # Add bidirectional edges\n                # Each edge stores: (neighbor_station, cost, time)\n                self.graph[station1].append((station2, cost, time))\n                self.graph[station2].append((station1, cost, time))\n\n        print(f\" Network loaded: {len(self.stations)} stations, \"\n              f\"{sum(len(neighbors) for neighbors in self.graph.values()) // 2} connections\")\n\n    except FileNotFoundError:\n        print(f\"Error: File '{filename}' not found!\")\n        exit(1)\n    except Exception as e:\n        print(f\"Error loading network: {e}\")\n        exit(1)\n</code></pre>"},{"location":"railway_network/#src.railway_network.RailwayNetwork.station_exists","title":"station_exists","text":"<pre><code>station_exists(station)\n</code></pre> <p>Check if a station exists in the network.</p> Source code in <code>src\\railway_network.py</code> <pre><code>def station_exists(self, station):\n    \"\"\"\n    Check if a station exists in the network.\n    \"\"\"\n    return station in self.stations\n</code></pre>"},{"location":"route_searcher/","title":"Route Searcher","text":"<p>This module implements the shortest path algorithm used to find optimal routes through the railway network.</p>"},{"location":"route_searcher/#src.route_searcher","title":"route_searcher","text":""},{"location":"route_searcher/#src.route_searcher.RouteSearcher","title":"RouteSearcher","text":"<p>Finds routes in a railway network using Dijkstra's algorithm.</p> Source code in <code>src\\route_searcher.py</code> <pre><code>class RouteSearcher:\n    \"\"\"\n    Finds routes in a railway network using Dijkstra's algorithm.\n    \"\"\"\n    def __init__(self, network):\n        \"\"\"\n        Initialize with a RailwayNetwork instance.\n        \"\"\"\n        self.network = network\n\n    def find_route(self, start, end, optimize_for='cost'):\n        \"\"\"\n        Find best route from start to end.\n\n        Returns path, total cost, total time, and edges explored.\n        \"\"\"\n        # Prevent search if graph is empty\n        if not self.network.graph:\n            print(\"Railway network is empty!\")\n            return None, None, None\n\n        # Run Dijkstra's algorithm\n        distances, parents, connections_explored = self._dijkstra(start, end, optimize_for)\n\n        # Check if destination is reachable\n        if end not in parents:\n            return None, None, None, connections_explored\n\n        # Reconstruct path\n        path = self._reconstruct_path(parents, start, end)\n\n        # Calculate total cost and time for the path\n        total_cost, total_time = self._calculate_route_details(path)\n\n        return path, total_cost, total_time, connections_explored\n\n    def _dijkstra(self, start, end, optimize_for):\n        \"\"\"\n        Internal Dijkstra algorithm to compute shortest paths.\n        \"\"\"\n\n        # counts explored edges\n        connections_explored = 0 \n\n        # Stop if invalid optimization choice\n        if optimize_for not in ['cost', 'time']:\n            return {}, {}\n\n        # Initialize data structures\n        distances = {station: float('infinity') for station in self.network.stations}\n        distances[start] = 0\n\n        parents = {start: None}\n        visited = set()\n\n        # Min-heap to always pick smallest distance\n        priority_queue = [(0, start)]\n\n        while priority_queue:\n            # Get station with minimum distance\n            current_distance, current_station = heapq.heappop(priority_queue)\n\n            # Skip if already visited (handles duplicate entries in queue)\n            if current_station in visited:\n                continue\n\n            # Mark as visited\n            visited.add(current_station)\n\n            # Early termination: found destination\n            if current_station == end:\n                break\n\n            # Explore neighbors\n            for neighbor, cost, time in self.network.get_neighbors(current_station):\n                connections_explored += 1\n\n                if neighbor not in visited:\n                    # Choose weight based on optimization criterion\n                    weight = cost if optimize_for == 'cost' else time\n\n                    # Calculate new distance\n                    new_distance = current_distance + weight\n\n                    # Relaxation step: update if found a shorter path\n                    if new_distance &lt; distances[neighbor]:\n                        distances[neighbor] = new_distance\n                        parents[neighbor] = current_station\n                        heapq.heappush(priority_queue, (new_distance, neighbor))\n\n        return distances, parents, connections_explored\n\n    def _reconstruct_path(self, parents, start, end):\n        \"\"\"\n        Reconstruct path from start to end using parent pointers.\n        \"\"\"\n\n        # Builds route from end to start\n        path = []\n        current = end\n\n        # Backtrack from end to start\n        while current is not None:\n            path.append(current)\n            current = parents.get(current)\n\n        # Reverse to get start \u2192 end order\n        path.reverse()\n\n        return path\n\n    def _calculate_route_details(self, path):\n        \"\"\"\n        Calculate total cost and travel time for a given path.\n        \"\"\"\n        total_cost = 0\n        total_time = 0\n\n        # Iterate through consecutive station pairs\n        for i in range(len(path) - 1):\n            current = path[i]\n            next_station = path[i + 1]\n\n            # Find the edge between current and next station\n            for neighbor, cost, time in self.network.get_neighbors(current):\n                if neighbor == next_station:\n                    total_cost += cost\n                    total_time += time\n                    break\n\n        return total_cost, total_time\n</code></pre>"},{"location":"route_searcher/#src.route_searcher.RouteSearcher.__init__","title":"__init__","text":"<pre><code>__init__(network)\n</code></pre> <p>Initialize with a RailwayNetwork instance.</p> Source code in <code>src\\route_searcher.py</code> <pre><code>def __init__(self, network):\n    \"\"\"\n    Initialize with a RailwayNetwork instance.\n    \"\"\"\n    self.network = network\n</code></pre>"},{"location":"route_searcher/#src.route_searcher.RouteSearcher.find_route","title":"find_route","text":"<pre><code>find_route(start, end, optimize_for='cost')\n</code></pre> <p>Find best route from start to end.</p> <p>Returns path, total cost, total time, and edges explored.</p> Source code in <code>src\\route_searcher.py</code> <pre><code>def find_route(self, start, end, optimize_for='cost'):\n    \"\"\"\n    Find best route from start to end.\n\n    Returns path, total cost, total time, and edges explored.\n    \"\"\"\n    # Prevent search if graph is empty\n    if not self.network.graph:\n        print(\"Railway network is empty!\")\n        return None, None, None\n\n    # Run Dijkstra's algorithm\n    distances, parents, connections_explored = self._dijkstra(start, end, optimize_for)\n\n    # Check if destination is reachable\n    if end not in parents:\n        return None, None, None, connections_explored\n\n    # Reconstruct path\n    path = self._reconstruct_path(parents, start, end)\n\n    # Calculate total cost and time for the path\n    total_cost, total_time = self._calculate_route_details(path)\n\n    return path, total_cost, total_time, connections_explored\n</code></pre>"},{"location":"user_interface/","title":"User Interface","text":"<p>This module manages all user interaction. It validates input, displays route results, and provides optimisation options.</p>"},{"location":"user_interface/#src.user_interface","title":"user_interface","text":""},{"location":"user_interface/#src.user_interface.UserInterface","title":"UserInterface","text":"<p>Handles user input, route selection, and output display.</p> Source code in <code>src\\user_interface.py</code> <pre><code>class UserInterface:\n    \"\"\"\n    Handles user input, route selection, and output display.\n    \"\"\"\n\n    def __init__(self, network, searcher):\n        \"\"\"Initialize with a railway network and route searcher.\"\"\"\n        self.network = network\n        self.searcher = searcher\n        # Pre-process station list for quick case-insensitive lookups\n        self.all_stations = list(self.network.stations)\n\n    def get_station_input(self, prompt):\n        \"\"\"Prompt user for a station name with fuzzy matching.\"\"\"\n        while True:\n            station_input = input(prompt).strip()\n\n            if not station_input:\n                print(\" Station name cannot be empty!\")\n                continue\n\n            # Exact match\n            if self.network.station_exists(station_input):\n                return station_input\n\n            # Case-insensitive match\n            for s in self.all_stations:\n                if s.lower() == station_input.lower():\n                    print(f\" Assuming you meant: '{s}'\")\n                    return s\n\n            # Fuzzy matching suggestions\n            matches = difflib.get_close_matches(\n                station_input,\n                self.all_stations,\n                n=3,\n                cutoff=0.6\n            )\n\n            print(f\" Station '{station_input}' not found in network.\")\n\n            if matches:\n                while True:\n                    print(\"\\n Did you mean one of these stations?\")\n                    for i, match in enumerate(matches, 1):\n                        print(f\" {i}. {match}\")\n                    print(\" X. Enter a new name\")\n\n                    choice = input(\" Enter choice (1, 2, 3 or X): \").strip().upper()\n\n                    if choice == 'X':\n                        break\n\n                    try:\n                        index = int(choice) - 1\n                        if 0 &lt;= index &lt; len(matches):\n                            return matches[index]\n                        else:\n                            print(\" Invalid choice. Try again.\")\n                    except ValueError:\n                        print(\" Invalid input. Enter 1, 2, 3 or X.\")\n            else:\n                print(\" No close matches found. Please try again.\")\n\n    def get_search_type(self):\n        \"\"\"Ask user whether to optimise for cost or time.\"\"\"\n        while True:\n            print(\"\\nOptimize for:\")\n            print(\"  1. Cheapest route (minimum cost)\")\n            print(\"  2. Fastest route (minimum time)\")\n            choice = input(\"Enter choice (1 or 2): \").strip()\n\n            if choice == '1':\n                return 'cost'\n            elif choice == '2':\n                return 'time'\n            else:\n                print(\" Invalid choice! Please enter 1 or 2.\")\n\n    def save_route_to_file(self, content):\n        \"\"\"Save route details to a file.\"\"\"\n        filename = \"route_details.txt\"\n        try:\n            with open(filename, 'w') as f:\n                f.write(content + \"\\n\\n\")\n            print(f\"\\n Route successfully saved to '{filename}'\")\n        except IOError as e:\n            print(f\" Error saving file: {e}\")\n\n    def display_route(self, path, total_cost, total_time, optimize_for, connections_explored):\n        \"\"\"Display route and journey summary.\"\"\"\n        output = []\n\n        output.append(\"ROUTE FOUND\\n\".center(70))\n\n        output.append(\" Cheapest Route\" if optimize_for == 'cost' else \" Fastest Route\")\n\n        output.append(\"\\nRoute (in order):\")\n        for i, station in enumerate(path, 1):\n            if i == 1:\n                output.append(f\" {i}. {station} (START)\")\n            elif i == len(path):\n                output.append(f\" {i}. {station} (DESTINATION)\")\n            else:\n                output.append(f\" {i}. {station}\")\n\n\n        output.append(\"\\nJourney Summary:\")\n        output.append(f\" \u2022 Total Stations: {len(path)}\")\n        output.append(f\" \u2022 Total Cost: \u00a3{total_cost}\")\n        output.append(f\" \u2022 Total Time: {total_time} minutes ({total_time // 60}h {total_time % 60}m)\")\n        output.append(f\" \u2022 Connections Explored: {connections_explored}\")\n\n        route_text = \"\\n\".join(output)\n        print(route_text)\n\n        self.save_route_to_file(route_text)\n\n    def run(self):\n        \"\"\"Main program loop for interacting with the user.\"\"\"\n        print(\"TRAIN TICKET SEARCH SYSTEM\".center(70))\n        print(\"\\nWelcome! Find the best train route between any two stations.\")\n        print(\"Note: All London stations are combined into 'London'\\n\")\n\n        while True:\n            departure = self.get_station_input(\"\\nEnter departure station: \")\n            destination = self.get_station_input(\"Enter destination station: \")\n\n            if departure == destination:\n                print(\"\\n Departure and destination are the same!\")\n                continue\n\n            search_type = self.get_search_type()\n\n            print(f\"\\n Searching for {'cheapest' if search_type == 'cost' else 'fastest'} route...\")\n\n            path, total_cost, total_time, connections_explored = self.searcher.find_route(\n                departure, destination, search_type\n            )\n\n            if path is None:\n                print(\"\\n No route found between these stations!\")\n            else:\n                self.display_route(\n                    path,\n                    total_cost,\n                    total_time,\n                    search_type,\n                    connections_explored\n                )\n\n            again = input(\"\\nSearch another route? (Y/N): \").strip().upper()\n            if again != 'Y':\n                break\n</code></pre>"},{"location":"user_interface/#src.user_interface.UserInterface.__init__","title":"__init__","text":"<pre><code>__init__(network, searcher)\n</code></pre> <p>Initialize with a railway network and route searcher.</p> Source code in <code>src\\user_interface.py</code> <pre><code>def __init__(self, network, searcher):\n    \"\"\"Initialize with a railway network and route searcher.\"\"\"\n    self.network = network\n    self.searcher = searcher\n    # Pre-process station list for quick case-insensitive lookups\n    self.all_stations = list(self.network.stations)\n</code></pre>"},{"location":"user_interface/#src.user_interface.UserInterface.display_route","title":"display_route","text":"<pre><code>display_route(path, total_cost, total_time, optimize_for, connections_explored)\n</code></pre> <p>Display route and journey summary.</p> Source code in <code>src\\user_interface.py</code> <pre><code>def display_route(self, path, total_cost, total_time, optimize_for, connections_explored):\n    \"\"\"Display route and journey summary.\"\"\"\n    output = []\n\n    output.append(\"ROUTE FOUND\\n\".center(70))\n\n    output.append(\" Cheapest Route\" if optimize_for == 'cost' else \" Fastest Route\")\n\n    output.append(\"\\nRoute (in order):\")\n    for i, station in enumerate(path, 1):\n        if i == 1:\n            output.append(f\" {i}. {station} (START)\")\n        elif i == len(path):\n            output.append(f\" {i}. {station} (DESTINATION)\")\n        else:\n            output.append(f\" {i}. {station}\")\n\n\n    output.append(\"\\nJourney Summary:\")\n    output.append(f\" \u2022 Total Stations: {len(path)}\")\n    output.append(f\" \u2022 Total Cost: \u00a3{total_cost}\")\n    output.append(f\" \u2022 Total Time: {total_time} minutes ({total_time // 60}h {total_time % 60}m)\")\n    output.append(f\" \u2022 Connections Explored: {connections_explored}\")\n\n    route_text = \"\\n\".join(output)\n    print(route_text)\n\n    self.save_route_to_file(route_text)\n</code></pre>"},{"location":"user_interface/#src.user_interface.UserInterface.get_search_type","title":"get_search_type","text":"<pre><code>get_search_type()\n</code></pre> <p>Ask user whether to optimise for cost or time.</p> Source code in <code>src\\user_interface.py</code> <pre><code>def get_search_type(self):\n    \"\"\"Ask user whether to optimise for cost or time.\"\"\"\n    while True:\n        print(\"\\nOptimize for:\")\n        print(\"  1. Cheapest route (minimum cost)\")\n        print(\"  2. Fastest route (minimum time)\")\n        choice = input(\"Enter choice (1 or 2): \").strip()\n\n        if choice == '1':\n            return 'cost'\n        elif choice == '2':\n            return 'time'\n        else:\n            print(\" Invalid choice! Please enter 1 or 2.\")\n</code></pre>"},{"location":"user_interface/#src.user_interface.UserInterface.get_station_input","title":"get_station_input","text":"<pre><code>get_station_input(prompt)\n</code></pre> <p>Prompt user for a station name with fuzzy matching.</p> Source code in <code>src\\user_interface.py</code> <pre><code>def get_station_input(self, prompt):\n    \"\"\"Prompt user for a station name with fuzzy matching.\"\"\"\n    while True:\n        station_input = input(prompt).strip()\n\n        if not station_input:\n            print(\" Station name cannot be empty!\")\n            continue\n\n        # Exact match\n        if self.network.station_exists(station_input):\n            return station_input\n\n        # Case-insensitive match\n        for s in self.all_stations:\n            if s.lower() == station_input.lower():\n                print(f\" Assuming you meant: '{s}'\")\n                return s\n\n        # Fuzzy matching suggestions\n        matches = difflib.get_close_matches(\n            station_input,\n            self.all_stations,\n            n=3,\n            cutoff=0.6\n        )\n\n        print(f\" Station '{station_input}' not found in network.\")\n\n        if matches:\n            while True:\n                print(\"\\n Did you mean one of these stations?\")\n                for i, match in enumerate(matches, 1):\n                    print(f\" {i}. {match}\")\n                print(\" X. Enter a new name\")\n\n                choice = input(\" Enter choice (1, 2, 3 or X): \").strip().upper()\n\n                if choice == 'X':\n                    break\n\n                try:\n                    index = int(choice) - 1\n                    if 0 &lt;= index &lt; len(matches):\n                        return matches[index]\n                    else:\n                        print(\" Invalid choice. Try again.\")\n                except ValueError:\n                    print(\" Invalid input. Enter 1, 2, 3 or X.\")\n        else:\n            print(\" No close matches found. Please try again.\")\n</code></pre>"},{"location":"user_interface/#src.user_interface.UserInterface.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Main program loop for interacting with the user.</p> Source code in <code>src\\user_interface.py</code> <pre><code>def run(self):\n    \"\"\"Main program loop for interacting with the user.\"\"\"\n    print(\"TRAIN TICKET SEARCH SYSTEM\".center(70))\n    print(\"\\nWelcome! Find the best train route between any two stations.\")\n    print(\"Note: All London stations are combined into 'London'\\n\")\n\n    while True:\n        departure = self.get_station_input(\"\\nEnter departure station: \")\n        destination = self.get_station_input(\"Enter destination station: \")\n\n        if departure == destination:\n            print(\"\\n Departure and destination are the same!\")\n            continue\n\n        search_type = self.get_search_type()\n\n        print(f\"\\n Searching for {'cheapest' if search_type == 'cost' else 'fastest'} route...\")\n\n        path, total_cost, total_time, connections_explored = self.searcher.find_route(\n            departure, destination, search_type\n        )\n\n        if path is None:\n            print(\"\\n No route found between these stations!\")\n        else:\n            self.display_route(\n                path,\n                total_cost,\n                total_time,\n                search_type,\n                connections_explored\n            )\n\n        again = input(\"\\nSearch another route? (Y/N): \").strip().upper()\n        if again != 'Y':\n            break\n</code></pre>"},{"location":"user_interface/#src.user_interface.UserInterface.save_route_to_file","title":"save_route_to_file","text":"<pre><code>save_route_to_file(content)\n</code></pre> <p>Save route details to a file.</p> Source code in <code>src\\user_interface.py</code> <pre><code>def save_route_to_file(self, content):\n    \"\"\"Save route details to a file.\"\"\"\n    filename = \"route_details.txt\"\n    try:\n        with open(filename, 'w') as f:\n            f.write(content + \"\\n\\n\")\n        print(f\"\\n Route successfully saved to '{filename}'\")\n    except IOError as e:\n        print(f\" Error saving file: {e}\")\n</code></pre>"}]}